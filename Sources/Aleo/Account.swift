//
//  Account.swift
//
//
//  Created by Nafeh Shoaib on 11/9/23.
//

import Foundation

/// Enables the creation of a new Aleo Account, importation of an existing account from an existing private key or seed, and message signing and verification functionality.
///
/// An Aleo Account is generated from a randomly generated seed (number) from which an account private key, view key, and a public account address are derived. The private key lies at the root of an Aleo account. It is a highly sensitive secret and should be protected as it allows for creation of Aleo Program executions and arbitrary value transfers. The View Key allows for decryption of a user's activity on the blockchain. The Address is the public address to which other users of Aleo can send Aleo credits and other records to. This class should only be used environments where the safety of the underlying key material can be assured.
public struct Account {
    var privateKey: PrivateKey
    
    var viewKey: ViewKey
    var address: Address
    
    /// Attempts to create an account from a private key.
    public init(privateKey: PrivateKey) {
        self.privateKey = privateKey
        
        self.viewKey = privateKey.viewKey
        self.address = privateKey.address
    }
    
    /// Attempts to create an account from a private key.
    public init?(privateKey: String) {
        guard let privateKey = PrivateKey(privateKey) else {
            return nil
        }
        
        self.init(privateKey: privateKey)
    }
    
    public init(seed: [UInt8]) {
        self.init(privateKey: PrivateKey(seed: seed))
    }
    
    /// Attempts to create an account from a private key ciphertext.
    public init?(ciphertext: PrivateKeyCiphertext, password: String) {
        guard let privateKey = PrivateKey(ciphertext: ciphertext, secret: password) else {
            return nil
        }
        
        self.init(privateKey: privateKey)
    }
    
    /// Attempts to create an account from a private key ciphertext.
    public init?(ciphertext: String, password: String) {
        guard let ciphertext = PrivateKeyCiphertext(ciphertext) else {
            return nil
        }
        self.init(ciphertext: ciphertext, password: password)
    }
    
    public func toString() -> String {
        return address.toString()
    }
    
    public func encryptAccount(with password: String) -> PrivateKeyCiphertext? {
        return privateKey.toCiphertext(secret: password)
    }
    
    /// Decrypt a record in ciphertext form into plaintext.
    ///
    /// - Parameter ciphertext: String representation of a record ciphertext.
    /// - Returns: String representation of a record plaintext.
    public func decryptRecord(ciphertext: String) -> String? {
        return viewKey.decrypt(ciphertext: ciphertext)
    }
    
    /// Decrypt an array of records in ciphertext form into plaintext.
    ///
    /// - Parameter ciphertexts: An array of string representations of record ciphertexts.
    /// - Returns: String representations of records plaintext.
    public func decryptRecords(ciphertexts: [String]) -> [String?] {
        return ciphertexts.map { viewKey.decrypt(ciphertext: $0) }
    }
    
    /// Determines if the account is the owner of the record.
    ///
    /// - Parameter viewKey: View key used to decrypt the ciphertext.
    public func isOwner(of ciphertext: RecordCiphertext) -> Bool {
        return ciphertext.isOwner(viewKey: viewKey)
    }
    
    /// Determines if the account is the owner of the record.
    ///
    /// - Parameter viewKey: View key used to decrypt the ciphertext.
    public func isOwner(of ciphertext: String) -> Bool {
        guard let ciphertext = RecordCiphertext(ciphertext) else {
            return false
        }
        
        return isOwner(of: ciphertext)
    }
    
    /// Sign a message with the private key.
    ///
    /// - Parameter message: Byte array representing a message signed by the address.
    /// - Returns: Signature generated by signing the message with the address.
    public func sign(message: [UInt8]) -> Signature {
        return privateKey.sign(message: message)
    }
    
    /// Verifies the Signature on a message.
    ///
    /// - Parameters:
    ///    - message: Byte array representing a message signed by the address.
    ///    - signature: Signature to verify message.
    /// - Returns: Whether or not the signature is valid
    public func verify(message: [UInt8], signature: Signature) -> Bool {
        return address.verify(message: message, with: signature)
    }
}
